#!/usr/bin/env ruby

# Add lib path so the project's files can be required.
$LOAD_PATH.unshift(File.expand_path('../../lib', __FILE__))

# Local files
require 'course-cli'

API_URL = "http://api.estagioemprogramacao.com"

include GLI::App

program_desc I18n.t('cli.program_desc')

version CourseCli::VERSION

subcommand_option_handling :normal
arguments :strict

# Global option: show help
desc I18n.t('cli.global_options.help.desc')
switch [I18n.t('cli.global_options.help.opt'), :help], negatable: false

# Global option: change debug level
desc I18n.t('cli.global_options.debug.desc', levels: CourseCli::DEBUG_LEVELS.join(' | '))
arg_name I18n.t('cli.global_options.debug.arg')
default_value 1
flag I18n.t('cli.global_options.debug.opt')

#
# Command: echo student code
#
desc I18n.t('cli.cmds.echo_student_code.desc')
command I18n.t('cli.cmds.echo_student_code.name') do |c|
  c.action do |global_options, options, args|
    puts CourseCli::UserConfig.student_code
  end
end

#
# Command: grade an exercise
#
desc I18n.t('cli.cmds.grade.desc')
arg_name I18n.t('cli.cmds.grade.arg')
command I18n.t('cli.cmds.grade.name') do |c|

  c.desc I18n.t('cli.cmds.grade.opts.hints.desc')
  c.switch I18n.t('cli.cmds.grade.opts.hints.opt'), negatable: false

  DIR_DEFAULT_VALUE = I18n.t('cli.cmds.grade.opts.dir.default')
  c.desc I18n.t('cli.cmds.grade.opts.dir.desc')
  c.arg_name I18n.t('cli.cmds.grade.opts.dir.arg')
  c.default_value DIR_DEFAULT_VALUE
  c.flag I18n.t('cli.cmds.grade.opts.dir.opt')

  c.action do |global_options, options, args|

    m, e = parse_exercise(args)

    begin
      grader = Graders.const_get("M#{m}").const_get("E#{e}")
    rescue
      exit_now!(I18n.t('cli.errors.grader_not_found', m: m, e: e))
    end

    if options[:dir] != DIR_DEFAULT_VALUE
      work_dir = File.expand_path(options[:dir])
      unless File.directory?(work_dir)
        exit_now!(I18n.t('cli.errors.work_dir_not_found',
                         work_dir: work_dir))
      end
    else
      work_dir = File.expand_path(File.dirname(__FILE__) + '/../..')
    end

    if CourseCli.debug_level > 0
      puts I18n.t('cli.debug_1.work_dir', work_dir: work_dir)
    end


    begin
      grader.new(work_dir: work_dir,
                 show_hints: options[I18n.t('cli.cmds.grade.opts.hints.opt')]).run
    rescue Exception => e
      puts Paint["Erro ao corrigir o exercício.", :red, :bold]
      puts e.message
      puts e.backtrace
      raise
    end
  end
end

#
# Command: submit an exercise
#
desc I18n.t('cli.cmds.submit.desc')
arg_name I18n.t('cli.cmds.submit.arg')
command I18n.t('cli.cmds.submit.name') do |c|
  c.action do |global_options, options, args|
    m, e = parse_exercise(args)

    # Check if the exercise has been graded before.
    unless File.exists?(CourseCli::PathHelper.gradings_file(m, e))
      exit_now!(I18n.t('cli.errors.exercise_not_graded', m: m, e: e,
                       grade_cmd: I18n.t('cli.cmds.grade.name')))
    end

    data = File.read(CourseCli::PathHelper.gradings_file(m, e))
    data = YAML.load(Encryption.decrypt(data), local_mode: false)

    puts I18n.t('cli.cmds.submit.msg_1')
    puts "-------------------"
    puts I18n.t('cli.cmds.submit.msg_2', m: data[:module], e: data[:exercise],
                at: Time.parse(data[:graded_at]).strftime("%d/%m/%Y %H:%M"))
    puts I18n.t('cli.cmds.submit.msg_3', pass_count: data[:pass_count],
                fail_count: data[:fail_count], skip_count: data[:skip_count])

    # data = Encryption.encrypt(data.to_json, local_mode: false)
    data = data.to_json

    config = YAML.load_file(File.join(CourseCli::PathHelper.user_folder, 'config'))

    puts
    puts I18n.t('cli.cmds.submit.msg_4')

    uri = URI("#{API_URL}/students/#{config[:student_code]}/lectures/cppe")
    res = Net::HTTP.post_form(uri, data: data)
    if res.code == "200"
      puts Paint["Ok.", :green]
    else
      res_json = JSON.parse(res.body)
      res_json.each do |_key, msg|
        puts Paint[msg, :red]
      end
    end
  end
end

#
# Command: show an exercise question
#
desc I18n.t('cli.cmds.show_exercise.desc')
arg_name I18n.t('cli.cmds.show_exercise.arg')
command I18n.t('cli.cmds.show_exercise.name') do |c|
  c.action do |global_options, options, args|
    m, e = parse_exercise(args)

    f = CourseCli::PathHelper.public_question_file(m, e)

    if File.exists?(f)
      CourseCli::QuestionViewer.view(f)
    else
      exit_now!(I18n.t('cli.errors.question_file_not_found', m: m, e: e))
    end
  end
end

#
# Command: download files from the API
#
desc I18n.t('cli.cmds.download.desc')
arg_name I18n.t('cli.cmds.download.arg')
command :download do |c|

  c.flag [:o, :output], desc: 'Arquivo ou diretório de destino'

  c.action do |global_options, options, args|

    student_code = CourseCli::UserConfig.student_code

    if student_code
      begin
        data = EP::API.get('downloads/supplies', {
          student_code: student_code,
          file_path: args[0]
        })
      rescue => ex
        if ex.respond_to?(:http_code)
          if ex.http_code == 401
            exit_now!(I18n.t('cli.errors.invalid_student_code', student_code: student_code))
          else
            exit_now!(I18n.t('cli.errors.download.file_not_found'))
          end
        else
          exit_now!("blablabla")
        end
      end
    end

    filename = File.basename(args[0])

    output_path = if options['output']
                    if File.directory?(options['output'])
                      "#{options['output']}/#{filename}"
                    elsif !File.exist?(options['output'])
                      options['output']
                    else
                      filename
                    end
                  else
                    filename
                  end

    begin
      File.open(output_path, 'wb') { |f| f.write(data) }
      puts "Arquivo criado em: #{output_path}"
    rescue => ex
      exit_now!("Erro ao criar o arquivo #{output_path}. Mensagem: #{ex.message}")
    end
  end
end

#
# Command: Configure student code
#

desc I18n.t('cli.cmds.configure.desc')
command I18n.t('cli.cmds.configure.name') do |c|
  t = ->(str) { I18n.t(str, scope: 'cli.cmds.configure.opts') }

  c.desc t['student_code.desc']
  c.arg_name t['student_code.arg']
  c.flag t['student_code.opt']

  c.desc t['force.desc']
  c.switch t['force.opt'], negatable: false

  c.action do |global_options, options, args|
    if options[t['student_code.opt']].nil?
      exit_now!(I18n.t('cli.errors.student_code_missing'))
    end

    if CourseCli.user_folder_exists? && !options[t['force.opt']]
      exit_now!(I18n.t('cli.errors.configuration_exists',
                      force_opt: t['force.opt']))
    end

    if student_exists?(options[t['student_code.opt']])
      CourseCli.setup(code: options[t['student_code.opt']])
    else
      puts exit_now!(I18n.t('cli.errors.student_not_found'))
    end
  end
end

# Pre logic here
# Return true to proceed; false to abort and not call the chosen command.
# Use skips_pre before a command to skip this block on that command only.
pre do |global, command, options, args|

  debug_level = global[I18n.t('cli.global_options.debug.opt')].to_i

  if CourseCli::DEBUG_LEVELS.include?(debug_level)
    CourseCli.debug_level = debug_level
  else
    help_now!(I18n.t('cli.errors.debug_level_invalid', level: debug_level,
                     debug_opt: I18n.t('cli.global_options.debug.opt')))

  end

  if CourseCli.debug_level > 1
    puts "[debug-2] global_options: #{global}"
    puts "[debug-2] options: #{options}"
    puts "[debug-2] args: #{args}"
  end

  # if [I18n.t('cli.cmds.grade.name'),
  #     I18n.t('cli.cmds.submit.name'),
  #     I18n.t('cli.cmds.show_exercise.name')].include?(command.name.to_s)
  #   unless CourseCli.check_user_folder
  #     exit_now!(I18n.t('cli.errors.configuration_missing'))
  #   end
  # end

  return_code = true

  ###
  # MOVE THIS TO ITS OWN METHOD
  #

  # if command.name.to_sym == :enunciado
  #   last_cli_update = CourseCli::UserConfig.last_cli_update

  #   if last_cli_update.nil? || (((Time.now - last_cli_update) / (60*60.0)) > 1)
  #     response = EP::API.get('downloads/cli/head')

  #     if response != CourseCli::UserConfig.last_sha
  #       puts "--------------------------------------------------------------------"
  #       puts "Uma nova versão do ep-cli está disponível!"
  #       puts "Pressione qualquer tecla para atualizar o ep-cli agora ou digite 'quit'"
  #       puts "para cancelar e atualizar manualmente com o comando 'ep-cli-update'"
  #       puts "--------------------------------------------------------------------"

  #       user_input = STDIN.gets.strip

  #       if user_input =~ /quit/i
  #         return_code = false
  #       else
  #         pid = fork do
  #           puts "Iniciando atualização..."
  #           exec("/bin/bash -c 'source /home/ubuntu/.ep/cli/install/bashrc && ep-cli-update'")
  #         end

  #         Process.wait(pid)
  #         puts "\n\n"
  #         puts Paint["Continuando com a execução do comando...", :green]
  #       end
  #     end
  #   end
  # end

  ###

  return_code
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only

  # Record analytics.
  CourseCli::Analytics.record_command(global, command, options, args)
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling

  # Record analytics.
  CourseCli::Analytics.record_error(exception)

  true
end

def parse_exercise(args)
  if args.empty?
    help_now!(I18n.t('cli.errors.exercise_missing'))
  elsif args.size > 1
    exit_now!(I18n.t('cli.errors.too_many_exercises', exs: args.join(', ')))
  end

  match = args[0].scan(/\A(\d+)\.(\d+)\z/)[0]

  if match.nil?
    exit_now!(I18n.t('cli.errors.exercise_invalid', ex: args[0]))
  end

  match.map { |x| x.rjust(2, '0') }
end

def student_exists?(code)
  res = Net::HTTP.get(URI("#{API_URL}/students/#{code}"))
  res == "OK!" ? true : false
end

exit run(ARGV)
